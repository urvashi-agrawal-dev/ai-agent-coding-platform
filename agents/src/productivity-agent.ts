import { AgentRequest, AgentResponse, AgentType, ProjectFile } from '../../shared/src/types';

interface DocumentationResult {
  readme: string;
  apiDocs: string;
  functionSummaries: FunctionSummary[];
  fileSummaries: FileSummary[];
  diagrams: DiagramSet;
}

interface FunctionSummary {
  name: string;
  description: string;
  parameters: ParamInfo[];
  returns: string;
  examples: string[];
  complexity: 'low' | 'medium' | 'high';
}

interface ParamInfo {
  name: string;
  type: string;
  description: string;
  optional: boolean;
}

interface FileSummary {
  path: string;
  purpose: string;
  exports: string[];
  dependencies: string[];
  linesOfCode: number;
}

interface DiagramSet {
  architectureDiagram: string;
  flowDiagram: string;
  classDiagram: string;
  sequenceDiagram: string;
}

export class ProductivityAgent {
  async process(request: AgentRequest): Promise<AgentResponse> {
    const action = request.context?.action || 'full';
    
    let result: any;
    
    switch (action) {
      case 'readme':
        result = this.generateReadme(request.code, request.projectFiles, request.context);
        break;
      case 'docs':
        result = this.generateDocumentation(request.code, request.projectFiles);
        break;
      case 'summary':
        result = this.summarizeCode(request.code, request.projectFiles);
        break;
      case 'diagrams':
        result = this.generateDiagrams(request.code, request.projectFiles);
        break;
      default:
        result = this.fullDocumentationSuite(request.code, request.projectFiles, request.context);
    }
    
    return {
      agentType: AgentType.PRODUCTIVITY,
      success: true,
      data: result,
      suggestions: this.generateSuggestions(result),
      timestamp: new Date()
    };
  }

  private fullDocumentationSuite(
    code: string,
    files?: ProjectFile[],
    context?: any
  ): DocumentationResult {
    const projectFiles = files || [{ path: 'main.js', content: code, language: 'javascript' }];
    
    return {
      readme: this.generateReadme(code, projectFiles, context),
      apiDocs: this.generateApiDocs(projectFiles),
      functionSummaries: this.generateFunctionSummaries(projectFiles),
      fileSummaries: this.generateFileSummaries(projectFiles),
      diagrams: this.generateDiagrams(code, projectFiles)
    };
  }

  private summarizeCode(code: string, files?: ProjectFile[]) {
    const projectFiles = files || [{ path: 'main.js', content: code, language: 'javascript' }];
    return {
      functionSummaries: this.generateFunctionSummaries(projectFiles),
      fileSummaries: this.generateFileSummaries(projectFiles)
    };
  }

  private generateDocumentation(code: string, files?: ProjectFile[]) {
    const projectFiles = files || [{ path: 'main.js', content: code, language: 'javascript' }];
    return {
      apiDocs: this.generateApiDocs(projectFiles),
      functionSummaries: this.generateFunctionSummaries(projectFiles)
    };
  }

  private generateReadme(code: string, files?: ProjectFile[], context?: any): string {
    const projectName = context?.projectName || 'Project';
    const description = context?.description || this.inferProjectDescription(files || []);
    const features = this.extractFeatures(files || []);
    const installation = this.generateInstallationInstructions(files || []);
    const usage = this.generateUsageExamples(files || []);
    const api = this.generateApiSection(files || []);
    
    return `# ${projectName}

${description}

## Features

${features.map(f => `- ${f}`).join('\n')}

## Installation

\`\`\`bash
${installation}
\`\`\`

## Usage

${usage}

## API Reference

${api}

## Project Structure

\`\`\`
${this.generateProjectTree(files || [])}
\`\`\`

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT License - feel free to use this project for any purpose.

## Support

For issues and questions, please open an issue on GitHub.

---

*Documentation generated by ProductivityAgent on ${new Date().toISOString()}*
`;
  }

  private inferProjectDescription(files: ProjectFile[]): string {
    const hasExpress = files.some(f => f.content.includes('express'));
    const hasReact = files.some(f => f.content.includes('react'));
    const hasDatabase = files.some(f => 
      f.content.includes('mongoose') || 
      f.content.includes('sequelize') ||
      f.content.includes('prisma')
    );
    
    let desc = 'A modern application';
    
    if (hasReact && hasExpress) {
      desc = 'A full-stack web application with React frontend and Express backend';
    } else if (hasReact) {
      desc = 'A React-based web application';
    } else if (hasExpress) {
      desc = 'A Node.js backend API built with Express';
    }
    
    if (hasDatabase) {
      desc += ' with database integration';
    }
    
    return desc + '.';
  }

  private extractFeatures(files: ProjectFile[]): string[] {
    const features: string[] = [];
    
    // Detect common features
    if (files.some(f => f.path.includes('auth'))) {
      features.push('User authentication and authorization');
    }
    if (files.some(f => f.path.includes('api') || f.path.includes('route'))) {
      features.push('RESTful API endpoints');
    }
    if (files.some(f => f.content.includes('websocket') || f.content.includes('socket.io'))) {
      features.push('Real-time communication with WebSockets');
    }
    if (files.some(f => f.path.includes('test'))) {
      features.push('Comprehensive test coverage');
    }
    if (files.some(f => f.content.includes('typescript'))) {
      features.push('TypeScript for type safety');
    }
    if (files.some(f => f.content.includes('jwt'))) {
      features.push('JWT-based authentication');
    }
    if (files.some(f => f.path.includes('middleware'))) {
      features.push('Custom middleware for request processing');
    }
    
    if (features.length === 0) {
      features.push('Clean, modular code structure');
      features.push('Easy to extend and maintain');
    }
    
    return features;
  }

  private generateInstallationInstructions(files: ProjectFile[]): string {
    const hasPackageJson = files.some(f => f.path.includes('package.json'));
    const hasPython = files.some(f => f.path.endsWith('.py'));
    
    if (hasPackageJson) {
      return `# Clone the repository
git clone <repository-url>
cd <project-name>

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env

# Run the application
npm start`;
    }
    
    if (hasPython) {
      return `# Clone the repository
git clone <repository-url>
cd <project-name>

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
python main.py`;
    }
    
    return `# Clone the repository
git clone <repository-url>
cd <project-name>

# Follow setup instructions in the documentation`;
  }

  private generateUsageExamples(files: ProjectFile[]): string {
    const examples: string[] = [];
    
    // Find main entry points
    const mainFiles = files.filter(f => 
      f.path.includes('index') || 
      f.path.includes('main') || 
      f.path.includes('app')
    );
    
    if (mainFiles.length > 0) {
      const file = mainFiles[0];
      
      // Extract example usage from code
      if (file.content.includes('express')) {
        examples.push(`### Starting the Server

\`\`\`javascript
npm start
// Server will run on http://localhost:3000
\`\`\``);
      }
      
      // Find exported functions
      const exportMatches = file.content.match(/export\s+(?:function|const)\s+(\w+)/g);
      if (exportMatches && exportMatches.length > 0) {
        const funcName = exportMatches[0].match(/(\w+)$/)?.[0];
        examples.push(`### Using the API

\`\`\`javascript
import { ${funcName} } from './${file.path}';

const result = ${funcName}(/* parameters */);
console.log(result);
\`\`\``);
      }
    }
    
    if (examples.length === 0) {
      examples.push(`### Basic Usage

\`\`\`javascript
// Import the module
const module = require('./main');

// Use the functionality
module.run();
\`\`\``);
    }
    
    return examples.join('\n\n');
  }

  private generateApiSection(files: ProjectFile[]): string {
    const apiFiles = files.filter(f => 
      f.path.includes('route') || 
      f.path.includes('api') || 
      f.path.includes('controller')
    );
    
    if (apiFiles.length === 0) {
      return 'No API endpoints detected.';
    }
    
    let apiDocs = '';
    
    for (const file of apiFiles) {
      const endpoints = this.extractEndpoints(file.content);
      if (endpoints.length > 0) {
        apiDocs += `### ${file.path}\n\n`;
        for (const endpoint of endpoints) {
          apiDocs += `#### ${endpoint.method} ${endpoint.path}\n\n`;
          apiDocs += `${endpoint.description}\n\n`;
          if (endpoint.params.length > 0) {
            apiDocs += `**Parameters:**\n${endpoint.params.map(p => `- \`${p}\``).join('\n')}\n\n`;
          }
        }
      }
    }
    
    return apiDocs || 'API documentation will be added soon.';
  }

  private extractEndpoints(content: string): Array<{
    method: string;
    path: string;
    description: string;
    params: string[];
  }> {
    const endpoints: Array<any> = [];
    const methods = ['get', 'post', 'put', 'delete', 'patch'];
    
    for (const method of methods) {
      const regex = new RegExp(`router\\.${method}\\(['"]([^'"]+)['"]`, 'g');
      let match;
      while ((match = regex.exec(content)) !== null) {
        const path = match[1];
        const params = path.match(/:(\w+)/g)?.map(p => p.substring(1)) || [];
        
        endpoints.push({
          method: method.toUpperCase(),
          path,
          description: `${method.toUpperCase()} endpoint for ${path}`,
          params
        });
      }
    }
    
    return endpoints;
  }

  private generateProjectTree(files: ProjectFile[]): string {
    const tree: string[] = [];
    const paths = files.map(f => f.path).sort();
    
    const buildTree = (paths: string[], prefix = '') => {
      const grouped: { [key: string]: string[] } = {};
      
      for (const path of paths) {
        const parts = path.split('/');
        if (parts.length === 1) {
          tree.push(`${prefix}├── ${path}`);
        } else {
          const dir = parts[0];
          if (!grouped[dir]) grouped[dir] = [];
          grouped[dir].push(parts.slice(1).join('/'));
        }
      }
      
      for (const [dir, subPaths] of Object.entries(grouped)) {
        tree.push(`${prefix}├── ${dir}/`);
        buildTree(subPaths, prefix + '│   ');
      }
    };
    
    buildTree(paths);
    return tree.join('\n');
  }

  private generateApiDocs(files: ProjectFile[]): string {
    let docs = '# API Documentation\n\n';
    
    for (const file of files) {
      const functions = this.extractFunctions(file.content);
      if (functions.length > 0) {
        docs += `## ${file.path}\n\n`;
        for (const func of functions) {
          docs += this.generateFunctionDoc(func);
        }
      }
    }
    
    return docs;
  }

  private extractFunctions(content: string): Array<{
    name: string;
    params: string[];
    isAsync: boolean;
  }> {
    const functions: Array<any> = [];
    
    // Regular functions
    const funcRegex = /(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)/g;
    let match;
    while ((match = funcRegex.exec(content)) !== null) {
      functions.push({
        name: match[1],
        params: match[2].split(',').map(p => p.trim()).filter(p => p),
        isAsync: content.substring(Math.max(0, match.index - 10), match.index).includes('async')
      });
    }
    
    // Arrow functions
    const arrowRegex = /(?:export\s+)?(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\(([^)]*)\)\s*=>/g;
    while ((match = arrowRegex.exec(content)) !== null) {
      functions.push({
        name: match[1],
        params: match[2].split(',').map(p => p.trim()).filter(p => p),
        isAsync: content.substring(match.index, match.index + 50).includes('async')
      });
    }
    
    return functions;
  }

  private generateFunctionDoc(func: any): string {
    return `### ${func.name}

${func.isAsync ? '**Async Function**' : '**Function**'}

**Parameters:**
${func.params.length > 0 ? func.params.map((p: string) => `- \`${p}\``).join('\n') : 'None'}

**Returns:** ${func.isAsync ? 'Promise' : 'Value'}

**Example:**
\`\`\`javascript
${func.isAsync ? 'await ' : ''}${func.name}(${func.params.map((p: string) => `/* ${p} */`).join(', ')})
\`\`\`

---

`;
  }

  private generateFunctionSummaries(files: ProjectFile[]): FunctionSummary[] {
    const summaries: FunctionSummary[] = [];
    
    for (const file of files) {
      const functions = this.extractFunctions(file.content);
      for (const func of functions) {
        summaries.push({
          name: func.name,
          description: this.inferFunctionPurpose(func.name),
          parameters: func.params.map((p: string) => ({
            name: p,
            type: this.inferType(p),
            description: `The ${p} parameter`,
            optional: false
          })),
          returns: func.isAsync ? 'Promise<any>' : 'any',
          examples: [`${func.name}(${func.params.map((p: string) => this.generateExampleValue(p)).join(', ')})`],
          complexity: this.calculateComplexity(file.content, func.name)
        });
      }
    }
    
    return summaries;
  }

  private inferFunctionPurpose(name: string): string {
    const nameLower = name.toLowerCase();
    
    if (nameLower.startsWith('get')) return `Retrieves ${name.substring(3)}`;
    if (nameLower.startsWith('set')) return `Sets ${name.substring(3)}`;
    if (nameLower.startsWith('create')) return `Creates a new ${name.substring(6)}`;
    if (nameLower.startsWith('update')) return `Updates ${name.substring(6)}`;
    if (nameLower.startsWith('delete')) return `Deletes ${name.substring(6)}`;
    if (nameLower.startsWith('fetch')) return `Fetches ${name.substring(5)}`;
    if (nameLower.startsWith('handle')) return `Handles ${name.substring(6)}`;
    if (nameLower.startsWith('process')) return `Processes ${name.substring(7)}`;
    if (nameLower.startsWith('validate')) return `Validates ${name.substring(8)}`;
    
    return `Performs ${name} operation`;
  }

  private inferType(paramName: string): string {
    const nameLower = paramName.toLowerCase();
    
    if (nameLower.includes('id')) return 'string | number';
    if (nameLower.includes('name')) return 'string';
    if (nameLower.includes('count') || nameLower.includes('num')) return 'number';
    if (nameLower.includes('is') || nameLower.includes('has')) return 'boolean';
    if (nameLower.includes('list') || nameLower.includes('array')) return 'Array<any>';
    if (nameLower.includes('data') || nameLower.includes('obj')) return 'object';
    
    return 'any';
  }

  private generateExampleValue(paramName: string): string {
    const type = this.inferType(paramName);
    
    if (type.includes('string')) return `"example"`;
    if (type.includes('number')) return '1';
    if (type.includes('boolean')) return 'true';
    if (type.includes('Array')) return '[]';
    if (type.includes('object')) return '{}';
    
    return 'value';
  }

  private calculateComplexity(content: string, funcName: string): 'low' | 'medium' | 'high' {
    const funcStart = content.indexOf(funcName);
    if (funcStart === -1) return 'low';
    
    const funcBlock = this.extractFunctionBlock(content, funcStart);
    const lines = funcBlock.split('\n').length;
    const branches = (funcBlock.match(/if|else|switch|case|\?/g) || []).length;
    const loops = (funcBlock.match(/for|while|forEach|map|filter/g) || []).length;
    
    const score = lines + branches * 2 + loops * 2;
    
    if (score > 50) return 'high';
    if (score > 20) return 'medium';
    return 'low';
  }

  private extractFunctionBlock(content: string, startIndex: number): string {
    let braceCount = 0;
    let inBlock = false;
    let result = '';
    
    for (let i = startIndex; i < content.length; i++) {
      if (content[i] === '{') {
        inBlock = true;
        braceCount++;
      } else if (content[i] === '}') {
        braceCount--;
      }
      
      if (inBlock) {
        result += content[i];
        if (braceCount === 0) break;
      }
    }
    
    return result;
  }

  private generateFileSummaries(files: ProjectFile[]): FileSummary[] {
    return files.map(file => ({
      path: file.path,
      purpose: this.inferFilePurpose(file.path, file.content),
      exports: this.extractExports(file.content),
      dependencies: this.extractDependencies(file.content),
      linesOfCode: file.content.split('\n').length
    }));
  }

  private inferFilePurpose(path: string, content: string): string {
    if (path.includes('route')) return 'Defines API routes and endpoints';
    if (path.includes('controller')) return 'Handles business logic for requests';
    if (path.includes('model')) return 'Defines data models and schemas';
    if (path.includes('service')) return 'Provides business logic services';
    if (path.includes('util') || path.includes('helper')) return 'Utility functions and helpers';
    if (path.includes('middleware')) return 'Express middleware functions';
    if (path.includes('config')) return 'Configuration settings';
    if (path.includes('test')) return 'Test cases and specifications';
    if (path.includes('component')) return 'React component';
    
    return 'Application module';
  }

  private extractExports(content: string): string[] {
    const exports: string[] = [];
    const exportRegex = /export\s+(?:default\s+)?(?:class|function|const|let|var)\s+(\w+)/g;
    let match;
    while ((match = exportRegex.exec(content)) !== null) {
      exports.push(match[1]);
    }
    return exports;
  }

  private extractDependencies(content: string): string[] {
    const deps: string[] = [];
    const importRegex = /(?:import|require)\s*\(?['"]([^'"]+)['"]\)?/g;
    let match;
    while ((match = importRegex.exec(content)) !== null) {
      deps.push(match[1]);
    }
    return [...new Set(deps)];
  }

  private generateDiagrams(code: string, files?: ProjectFile[]): DiagramSet {
    const projectFiles = files || [{ path: 'main.js', content: code, language: 'javascript' }];
    
    return {
      architectureDiagram: this.generateArchitectureDiagram(projectFiles),
      flowDiagram: this.generateFlowDiagram(code),
      classDiagram: this.generateClassDiagram(projectFiles),
      sequenceDiagram: this.generateSequenceDiagram(code)
    };
  }

  private generateArchitectureDiagram(files: ProjectFile[]): string {
    // Generate Mermaid diagram
    let diagram = '```mermaid\ngraph TB\n';
    
    const layers: { [key: string]: string[] } = {
      presentation: [],
      api: [],
      business: [],
      data: []
    };
    
    for (const file of files) {
      if (file.path.includes('component') || file.path.includes('view')) {
        layers.presentation.push(file.path);
      } else if (file.path.includes('route') || file.path.includes('controller')) {
        layers.api.push(file.path);
      } else if (file.path.includes('service') || file.path.includes('handler')) {
        layers.business.push(file.path);
      } else if (file.path.includes('model') || file.path.includes('repository')) {
        layers.data.push(file.path);
      }
    }
    
    let nodeId = 0;
    const nodeMap: { [key: string]: string } = {};
    
    for (const [layer, fileList] of Object.entries(layers)) {
      if (fileList.length > 0) {
        diagram += `  subgraph ${layer}[${layer.toUpperCase()} LAYER]\n`;
        for (const file of fileList) {
          const id = `node${nodeId++}`;
          nodeMap[file] = id;
          diagram += `    ${id}[${file}]\n`;
        }
        diagram += `  end\n`;
      }
    }
    
    // Add connections
    if (layers.presentation.length > 0 && layers.api.length > 0) {
      diagram += `  ${nodeMap[layers.presentation[0]]} --> ${nodeMap[layers.api[0]]}\n`;
    }
    if (layers.api.length > 0 && layers.business.length > 0) {
      diagram += `  ${nodeMap[layers.api[0]]} --> ${nodeMap[layers.business[0]]}\n`;
    }
    if (layers.business.length > 0 && layers.data.length > 0) {
      diagram += `  ${nodeMap[layers.business[0]]} --> ${nodeMap[layers.data[0]]}\n`;
    }
    
    diagram += '```';
    return diagram;
  }

  private generateFlowDiagram(code: string): string {
    let diagram = '```mermaid\nflowchart TD\n';
    diagram += '  Start([Start]) --> Process[Process Data]\n';
    
    if (code.includes('if')) {
      diagram += '  Process --> Decision{Condition?}\n';
      diagram += '  Decision -->|Yes| ActionA[Action A]\n';
      diagram += '  Decision -->|No| ActionB[Action B]\n';
      diagram += '  ActionA --> End([End])\n';
      diagram += '  ActionB --> End\n';
    } else {
      diagram += '  Process --> End([End])\n';
    }
    
    diagram += '```';
    return diagram;
  }

  private generateClassDiagram(files: ProjectFile[]): string {
    let diagram = '```mermaid\nclassDiagram\n';
    
    for (const file of files) {
      const classes = this.extractClasses(file.content);
      for (const cls of classes) {
        diagram += `  class ${cls.name} {\n`;
        for (const method of cls.methods) {
          diagram += `    +${method}()\n`;
        }
        diagram += `  }\n`;
      }
    }
    
    diagram += '```';
    return diagram;
  }

  private extractClasses(content: string): Array<{ name: string; methods: string[] }> {
    const classes: Array<any> = [];
    const classRegex = /class\s+(\w+)/g;
    let match;
    
    while ((match = classRegex.exec(content)) !== null) {
      const className = match[1];
      const methods = this.extractClassMethods(content, match.index);
      classes.push({ name: className, methods });
    }
    
    return classes;
  }

  private extractClassMethods(content: string, startIndex: number): string[] {
    const methods: string[] = [];
    const classBlock = this.extractFunctionBlock(content, startIndex);
    const methodRegex = /(\w+)\s*\([^)]*\)\s*{/g;
    let match;
    
    while ((match = methodRegex.exec(classBlock)) !== null) {
      if (match[1] !== 'constructor') {
        methods.push(match[1]);
      }
    }
    
    return methods;
  }

  private generateSequenceDiagram(code: string): string {
    let diagram = '```mermaid\nsequenceDiagram\n';
    diagram += '  participant Client\n';
    diagram += '  participant Server\n';
    diagram += '  participant Database\n';
    diagram += '  Client->>Server: Request\n';
    diagram += '  Server->>Database: Query\n';
    diagram += '  Database-->>Server: Result\n';
    diagram += '  Server-->>Client: Response\n';
    diagram += '```';
    return diagram;
  }

  private generateSuggestions(result: any): string[] {
    const suggestions: string[] = [];
    
    if (result.readme) {
      suggestions.push('README.md generated - review and customize as needed');
    }
    if (result.apiDocs) {
      suggestions.push('Add more detailed API examples');
    }
    if (result.functionSummaries) {
      const highComplexity = result.functionSummaries.filter((f: any) => f.complexity === 'high');
      if (highComplexity.length > 0) {
        suggestions.push(`Consider refactoring ${highComplexity.length} high-complexity function(s)`);
      }
    }
    
    suggestions.push('Keep documentation up to date with code changes');
    suggestions.push('Add inline comments for complex logic');
    
    return suggestions;
  }
}
